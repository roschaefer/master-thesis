\documentclass{article}
\usepackage{todonotes}
\usepackage{biblatex}
\usepackage{listings}
\usepackage{color}
\usepackage{copyrightbox}
\usepackage{ccicons}
\usepackage{booktabs}
\usepackage{wrapfig}
\usepackage{subfig}
\usepackage{tabulary}
\usepackage{amssymb}
\usepackage[inline]{enumitem}
\definecolor{lightgray}{rgb}{.9,.9,.9}%
\definecolor{darkgray}{rgb}{.4,.4,.4}%
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstdefinelanguage{JavaScript}{%
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  sensitive=true
}

\lstset{%
  language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
 }
\bibliography{bibliography}

\newcommand{\rufu}{\textsc{Rundfunk MITBESTIMMEN}}
\newcommand{\visan}{\textsc{visual analytics platform}}
\newcommand\hmm[1]{\ifnum\ifhmode\spacefactor\else2000\fi>1000 \uppercase{#1}\else#1\fi}
\newcommand{\cmv}{\hmm{c}oordinated multiple view}
\newcommand{\cmvs}{\hmm{c}oordinated multiple views}
\newcommand{\map}{\textsc{2D} map}
\newcommand{\maps}{\textsc{2D} maps}
\newcommand{\tmap}{\textsc{2.5D} tree map}
\newcommand{\tmaps}{\textsc{2.5D} tree maps}
\newcommand{\threedTmap}{\textsc{3D} tree map}
\newcommand{\threedTmaps}{\textsc{3D} tree maps}
\newcommand{\twodTmaps}{\textsc{2D} tree maps}
\newcommand{\dss}{\hmm{d}ecision support systems}
\newcommand{\riso}{\texttt{RISO}}
\newcommand{\attr}[1]{\texttt{\detokenize{#1}}}
\newenvironment{bullshit}{\color{gray}}{\ignorespacesafterend}

\newcommand{\conceptTable}[3]{%
    \begin{center}
    {\small
        \begin{tabulary}{\textwidth}{ll}
            \bf Data structure & #1 \\

            \bf Dependent visual attributes & #2 \\

            \bf Independent visual attributes & #3  \\
        \end{tabulary}
    }
    \end{center}
}

\begin{document}

\title{Multiple coordinated views on massive geo data}
\author{Robert Schäfer, Hasso-Plattner-Institut}
\maketitle
\clearpage

\tableofcontents
\clearpage



\begin{abstract}
  Numerous visualization techniques exist for data-driven \dss{}.
  Those systems primarily used to give guidance in geopolitical decisions often deal with hierarchical and geographical data.
  There are well-researched data visualizations for both kinds individually.
  For geographical there are choropleth maps, flow maps, bubble maps and for hierarchical data there are treemaps.
  To this day however, no appropriate data visualization for hierarchical and geographical information in one view exists.
  In this thesis, we evaluate \cmvs{} to combine the capabilities of both data visualizations.
  We describe a framework to coordinate arbitrary data visualizations in theoretical terms and we give a reference implementation.

\end{abstract}
\clearpage

\section{Introduction}
The human brain processes visual information better than it processes text.
As a result, the most tangible data analyses usually come with some sort of data visualization.
On a computer, the user can interact with the data and explore different levels of granularity.
The visualization changes and the user can iteratively perform another interaction.
In many cases a great interactivity results in a great user experience.

There is a wide range of existing frameworks and implementations for data visualizations.
In some advanced cases, the data is visualized in multiple views which are linked with each other.
These \cmvs{} are interesting, as they try to make the most out of the various advantages of different visualizations.
However, implementing interactions on data visualizations, and especially on multiple visiualization, is tedious and costly.
There is currently no extensible framework that helps to implement interactions of the same data in various visualizations.

% Three moves
%\todo{What is the topic about?}
\todo[inline]{Establish the niche, why is there further research on your topic?}
\todo[inline]{Introduce the current research, what's the hypothesis, the research question?}

\subsection{Motivation}\label{sec:outline}

We create data visualizations of multi-dimensional, hierarchical and geographical data.
Namely, we develop \rufu{} which is an application for German citizen to publish which public broadcasts should benefit from their broadcasting fees.
The output of this application is a public user ranking and it can be used by broadcasting corporations to evaluate their program.
Visualizations of multidimensional, hierarhical data guide media researchers, journalists and the general audience to draw conclusions.

To explain this a little deeper:
Public broadcasting in Germany is organized federally, a German home belongs to the jurisdiction of a public broadcasting corporation.
But the produced content can be used by all German citizen and it is even required to be free and available for everyone.
In the application, common users vote on the entire collection of broadcasts but media researchers are only interested in users of a service area.
User accounts have a local context and broadcasts have a global context.

Let's say a media researcher is interacting with two views of the data.
The interaction may happen in one view but is reflected in another view.
E.g.\ the researcher selects user accounts from a geographical map but has the intention to update a separate view.
That view could show e.g.\ a listing of the most popular broadcasts, based on the data of user accounts from that area.

Having the interaction spread across several views creates a great value for the user but the implementation this functionality is very tedious.
We see a strong demand for \cmvs{} and the development effort as the main obstacle.
A \cmv{} composed of arbitrary charts and plots and the implementation of their interactions turns into an unsustainable amount of work.

\subsection{Problem Statement}
%
% \tmaps{} visualize hierarchical data on a two dimensional canvas and are particularly suitable if the proportions of the data should be emphasized.
% When dealing with both multidimensional and geographical data, problems arise when features other than geographical features are used as input of the tiling algorithm.
% This impairs the comprehensibility and complicates the selection of geographical units of items.
% A second problem is the coordination of interactions among arbitrary data visualizations.

A \tmap{} of hierarchical, geographical data can loose the geographic context if the tiling algorithm is based on non-geographical features.
Items that should belong together according to their geographic circumstances may be scattered across the \tmap{}.
This impairs the comprehensibility and complicates the selection of geographical units of items.

\subsection{Hypothesis}

A second, geographical visualization next to the \tmap{} can maintain the geographical context.
If an interaction in one visualization is reflected in the other, this further supports the analysis of the data.
Moreover, the limitations of a single data visualization can be avoided by interacting with the data trough another view.

%Hypothese ist, dass durchs Visualisierungs-, Navigations- und Interaktionstechniken eine Kopplung von georäumlichen 2D-Kartendarstellungen und thematisch-orientierten 3D-Treemaps ermöglicht wird und dadurch die Exploration und Analyse von multidimensionalen georäumlichen Daten unterstützt werden kann.

\subsection{Contributions}

In order to validate the conceptual framework for \cmvs{}, we develop a reference implementation to investigate its feasibility.
The development of the reference implementation is subdivided into the following packages:

\begin{enumerate}
  \item
    Concept

    Based on a number of examples, a basic, conceptual framework is designed.
    This includes a common data structure, a formalization of an interaction in general and the communication prototocol for multiple views.

  \item
    Implementation

    We develop a geographical represenatation of the data.
    Items in the map can be focused, highlighted, selected with multiple clicks or with a bounding box.
    This creates a powerful selection mechanism, which can be used to select data in map-based representations and highlight the data in the \tmap{}.

  \item
    Integration of \tmap{} and \map{}
    We develop linking and interaction mechanisms between \maps{} (for map-based representation) and \tmaps{} (for abstract information representation).

  \item
    Demonstration and evaluation

    \cmv{} layouts and suitable views are implemented and tested for the selected test data.
    Based on the test data sets, the \cmv{} implementation is examined and evaluated for design criteria~\cite{Baldonado2000}, general usability aspects~\cite{Roberts2007} and usage for typical visual analytics tasks.
\end{enumerate}

% \subsection{Methodological Approach}
%
% A literature research is used to gather knowledge about the current state of the art with respect to \cmvs{}.
% Existing concepts and implementations available on the internet are examined and reused if possible.
% Interviews of people from the target group are conducted and the define the requirements for the application.
% A minimal viable product is developed to further validate the user requirements.
% Also, common user behaviour is observed during user tests.
% The prototype is continuously developed to allow for further experimentation.
%
% \paragraph{Scenarios}
% While implementing more features, we have two scenarios with different kind of data and different user requirements:
% \begin{itemize}
%   \item
%     In our work on the project \rufu{} we design and prototype visualizations for media researchers.
%     We fully control the database and the database schema as well as on the user facing application on top of it.
%     User requirements are tied to journalists, media researchers, broadcasting corporations.
%     The data has geographical, hierarchical, temporal and correlated characteristics.
%   \item
%     The \visan{} for administrative data is used as a more general purpose application.
%     There is no single database schema but combatibility with many sources or services.
%     User requirements are potentially unknown and part of the resarch.
%     The usage focuses especially on geographical and hierarchical data.
% \end{itemize}
%
% For the scope of this master thesis we therefore compare implemented visualization and views.
% How do both approaches differ in development speed, value for the customer?
% What considerations need to be done regarding the database schema?
%
% \todo[inline]{What are the areas of research, in which this thesis can be placed into?}

\subsection{Structure of the Work}

In Section~\ref{sec:theory} we introduce basic terminology of \cmvs{} and the theoretical background in this area of research.
Section~\ref{sec:related-work} covers the state of the art and research on multiple views and coordinated interactions.
In Section~\ref{sec:analysis} we analyze a set of data visualizations and their interactions by example.
The gained knowledge from that section is used in the following Section~\ref{sec:concept} for a formalization of the \cmv{} framework.
In Section~\ref{sec:implementation} we describe the reference implementation.
Then in Section~\ref{sec:evaluation} we take the requirements from Section~\ref{sec:analysis} to evaluate the conceptual framework and its implementation.
Finally sum up the main contribution in Section~\ref{sec:conclusion} and outline the future work in Section~\ref{sec:future-work}.

\clearpage
\section{Foundations}\label{sec:theory}
\todo[inline]{no section without text}

\subsection{Data Visualizations}
Data visualizations is a means of visual communication and have steadily developed since the 16th century~\cite{Friendly2001}.
Otherwise abstract information is visually represented, making complex data more accessible, understandable and usable.
\textcite{Kusinitz2014} explains that the human brain processes visual information 60,000 times faster than text and visual content makes up even 93\% of all human communication.
The purpose of data visualizations is twofold, according to the Interaction Design Foundation: sense-making and communication.
Statistical information is abstract and in data visualization ``we must find a way to give form to that which has none.''~\cite{Few2013}
Successful data visualizations helps the human user to derive knowledge and meta data from the visualization itself, \textcite{Nocke2002} call it ``visual data mining''.

\paragraph{Data-driven \dss{}} are applications to support businesses and organizational decision-making activities in which data visualizations play a key part~\cite{Nada2007}~\cite{Poleto2015}.
Visualizations are an obvious choice for managers who demand a quick overview on performance data.
Stephen Few's book ``Show me the numbers'' was named after the phrase often used by sales managers who can't afford to wade through lengthy reports.
\todo[inline]{Prof. Döllner mentioned the emerging ``cockpit'' views}

We can expect to see these technologies more in more in business applications.
\textcite{McAfee2012} from the MIT Center of Digital Business showed that organizations driven most by data-based decision making had 4\% higher productivity rates and 6\% higher profits.
However, little research has been done regarding the performance of \cmvs{} in the field of decision making.
There might be a great potential.
Back in 1997 \textcite{Mayer1997} conducted eight studies to compare the effect of using multimedia on university students.
The studies showed that when using combined visual and verbal explanations the generation of creative problem solutions increased by an average of more than 50\%.

So the application of combined data visualization techniques in decision making seems to be a promising strategy.
Nevertheless is is unclear, which visualization techniques are the most suitable to be used in combination.
If we know what kind of data we are dealing with, what are the best suited visualization techniques?
Let's say we have multidimensional data, is there an order in how people access these multiple dimensions?
How do these visualizations perform and what are best practices to be considered for their implementation?


\subsection{Visual Variables}\label{sec:theory:visual-variables}
French cartographer Jaques Bertin introduced seven visual varables in 1967~\cite{Bertin2010}.
We can see an example for each in Figure~\ref{fig:theory:visual-variables}.
These visual variables are used in cartography but can also be applied to data visualization in general.
\textcite{Carpendale2003} explains in detail their use in terms of computational information instead of printed cartography.
\textcite{Garlandini2009} put these visual variables under systematical validation procedures.
The authors conclude that the variable size provides the most accurate and efficent performance while the variable orientation provides the least performance.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/visual-variables.png}
  \caption{Bertin's~\cite{Bertin2010} original visual variables.}\label{fig:theory:visual-variables}
\end{figure}

\subsection{Treemaps}
The visualization of hierarchical data has a long tradition.
The traditional visual representation of a tree is a directed graph with the root node at the top.
An everyday use case is a directory tree example of a file system, e.g.\ in file browsers or command line utilities like \texttt{tree} in UNIX based operating systems.
As \textcite{Shneiderman1992} mentions, this visualization becomes increasingly large when displaying more than one node and soon exceeds the entire screen size.
\textcite{Johnson1991} proposes the tree map visualization technique, in which each node is a rectangle whose area is proportional to a specified dimension.
Rectangles contain sub-branches of the node as tiles, thereby expressing hierarchy information.
\begin{figure}[h]
    \centering
    \copyrightbox[b]{%
        \includegraphics[width=\textwidth]{images/theory/german-exports-1}}{%
        \hfill \ccAttribution{} \ccShareAlike{} Observatory of Economic Complexity~\cite{Macro2017}
    }
    \caption{First hierarchy level of German exports}\label{fig:theory:treemap-german-exports-1}
\end{figure}

\begin{figure}[h]
    \centering
    \copyrightbox[b]{%
        \includegraphics[width=\textwidth]{images/theory/german-exports-2}}{%
        \hfill \ccAttribution{} \ccShareAlike{} Observatory of Economic Complexity~\cite{Macro2017}
    }
    \caption{Second hierarchy level of German exports}\label{fig:theory:treemap-german-exports-2}
\end{figure}
\todo[inline]{Why is the layout different in the second image?}

We can see an example of an interactive treemap in Figures~\ref{fig:theory:treemap-german-exports-1} and~\ref{fig:theory:treemap-german-exports-2}.
German exports are divided in generic groups like ``Machines'' and ``Chemical Products'' and include more specific groups like ``Cars'' and ``Packaged Medicaments''.
The level of hiearchy can be selected with a dropdown menu, so only leaf nodes are displayed at a time.
Treemaps are space-filling visualizations, i.e.\ they make 100\% use of the available screen size.

Note that as the order and placement of the nodes depends on the value of their specified dimension, geographical units of data may may be placed separately on the treemap.

\paragraph{\threedTmaps{}} is a concept introduced by \textcite{Bladh2004} in 2004.
The authors transfer the concept of tree maps from two dimensional into three dimensional space.
They introduce StepTree~\cite{Bladh2004}, which is a three dimensional tree map to display a directory layout.
It ``differs from Treemap in that it employs three dimensions by stacking each subdirectory on top of its parent directory.''
3D tree maps are superior to 2D tree maps for tasks with a pronounced topological challenge.
User perform significantly better in interpreting the hierarchical structure.
However, 3D visualizations also introduce some disadvantages as superimposition of objects and a complex view point navigation.

\paragraph{\tmap{}} is a term coined by \textcite{Limberger2016}.
A \tmap{} emphasizes physical constraints of a \threedTmap{}, i.e.\ a \tmap{} has all items attached to the ground.
We can see an example of a \tmap{} in figure~\ref{fig:research:ua_treemap}

\begin{figure}[h]
  \centering
  \copyrightbox[b]{%
    \includegraphics[width=\textwidth]{images/2_5D_treemap_example}}{%
    \hfill \textcopyright{} Hasso-Plattner-Institut\cite{Doellner2017}
  }
  \caption{Example of a \tmap{}}\label{fig:research:ua_treemap}
\end{figure}


\subsection{Geographical Data Visualization}
\todo[inline]{introduction}
\paragraph{Flow maps} place stroked lines on top of a geographic map.
They often display the flow of goods or the migration of people.
As we can see in Figure~\ref{fig:theory:flow-map}, an early example of a flow map is Charles Minard’s depiction of Napoleon’s ill-fated march on Moscow in 1861~\cite{Corbett2001}.
\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{images/theory/minard}
  \caption{%
    Charles Minard's map of Napoleon's disastrous Russian campaign of 1812.
    Minard managed to represent six values in two graphical dimensions:
    The number of Napoleon's troops, the travelled direction and distance, latitude and longitude relative to specific dates and the temperature.
  }\label{fig:theory:flow-map}
\end{figure}

\paragraph{Choropleth maps} is a thematic map in which areas are shaded or patterned in proportion to the statistical variable being displayed on the map.
A popular use case is the display of population density or per-capita income.
We can see an example of a choropleth map in Figure~\ref{fig:theory:choropleth}, showing the percentage of obese population in the US\@.
Choropleth maps are widely popular and likely to understand them.
They are very helpful when data is attached to enumeration unites like counties, provinces and countries.

\begin{figure}[h]
  \centering
  \copyrightbox[b]{%
    \includegraphics[width=\textwidth]{images/theory/choropleth}}{%
    \hfill National Center for Chronic Disease Prevention and Health Promotion~\cite{NCCDPHP2017}
  }
  \caption{%
    Choropleth Map of Obesity in the United States in 2008.
    Present of population classified as ``obese'' (Body Mass Index in excess of 30), by state.
  }\label{fig:theory:choropleth}
\end{figure}

\paragraph{Graduated Symbol Maps} is a good alternative to a choropleth maps, as it alleviates one of its downsides:
Larger areas may appear more emphasized than smaller ones, thus confounding geographic area with data values.
Instead, symbols are placed over the regions of a map.
As \textcite{Heer2010} point out, these symbols allow for more visal variables to be visualized, i.e.\  symbol size, shape and colour.

\paragraph{Cartograms} are used to encode a data attribute in the size of an area.
For this reason geographic regions in cartograms appear distorted.
A common example is to redraw the size of a country based on the the population or gross domestic product of a country.
Area cartograms may be contiguous or noncontiguous, depending on the applied layout algorithm.

\subsection{Coordinated Multiple Views}
According to \textcite{Roberts2007} \cmvs{} is just ``a specific exploratory visualization technique that enables users to explore their data''.
\cmvs{} are characterized by the fact, that they show multiple views side-by-side.
We can see an example in Figure~\ref{fig:research:cmv}.
It displays an on-time performance of airlines, visualized with the ``Crossfilter'' javascript library.
The user can set the borders of an interval with the mouse in each of the views.
The visualization takes the most recent 80 flights from the database that match all given filters.
All visualizations are then updated in real time.
As we can see in the example in Figure~\ref{fig:research:cmv} there seems to be a correlation of a long delay with a later time of the day.

\begin{figure}[h]
  \centering
  \copyrightbox[b]{\includegraphics[width=\textwidth]{images/cmv_example}}{\hfill Crossfilter\cite{Bostock2017}}
  \caption{Airline on-time performance: Correlation of time of day with arrival delay. Most recent flight with a delay of more than 100 minutes selected.}\label{fig:research:cmv}
\end{figure}

\paragraph{Brushing and Linking}
Most multiple coordinated views also provide some kind of brushing technique.
``The technique of brushing is the principle approach, where elements are selected (and highlighted) in one display, concurrently the same information in any other linked display is also highlighted.''\cite{Roberts2007}

\clearpage
\section{Related Work}\label{sec:related-work}
According to \textcite{Ho2013} interactions are a crucial part of data visualizations, yet most research in the area of data visualization still focuses on visual representations.
Roughly speaking, research on interaction falls into these groups:
How to categorize interaction techniques?
How to find new interaction techniques and apply those to visualizations?

\todo[inline]{Give a rough overview of this section}
\subsection{Interaction Categories}\label{sec:related-work:categories}
\textcite{Shneiderman1996} classifies interactions into these groups:
\begin{enumerate*}[label=(\arabic*)]
  \item
    Gain an \emph{overview} of the entire collection,
  \item
    \emph{zoom} in on items of interest,
  \item
    select an item or group and get \emph{details} when needed,
  \item
    view \emph{relationships} among items,
  \item
    keep a \emph{history} of actions to support undo,
  \item
    allow \emph{extraction} of sub-collections and of the query parameters.
\end{enumerate*}

In 1997 \textcite{Shneiderman1996} classified interactions into these groups:
\begin{enumerate*}[label=(\arabic*)]
  \item
    Gain an \emph{overview} of the entire collection,
  \item
    \emph{zoom} in on items of interest,
  \item
    select an item or group and get \emph{details} when needed,
  \item
    view \emph{relationships} among items,
  \item
    keep a \emph{history} of actions to support undo,
  \item
    allow \emph{extraction} of sub-collections and of the query parameters.
\end{enumerate*}

Two years later, \textcite{Dix1998} identified these categories:
\begin{enumerate*}[label=(\arabic*)]
  \item
    \emph{Highlight and focus} particular subsets of the data,
  \item
    instead of displaying everything simultaneously \emph{access extra information} by drilling down the data,
  \item
    zoom in and out to give an \emph{overview and context},
  \item
    \emph{change parameters} of the \emph{same representation}, e.g.\ another baseline of a stacked bar char,
  \item
    \emph{change representation} of the \emph{same data} by switching the chart type,
  \item
    \emph{link representations} to determine the relationship between items.
\end{enumerate*}

In 2002, \textcite{Keim2002} comes up with the following classification:
\begin{enumerate*}[label=(\arabic*)]
  \item
    Dynamic \emph{projection} to show all combination of data attributes mapped to the axis of a diagram,
  \item
    focus on a smaller subsets by \emph{filtering} out parts of the data,
  \item
    \emph{zoom} into a subset of the data and get a higher level of detail,
  \item
    preserve an overview of the data during drill-down operations is called \emph{distortion}
  \item
    and finally \emph{link and brush} visualizations, to highlight the same data points in multiple visualizations.
\end{enumerate*}

The most recent classification was done in 2007 by \textcite{Yi2007} listing seven categories:
\begin{enumerate*}[label=(\arabic*)]
  \item
    \emph{Select} to mark something as interesting,
  \item
    \emph{explore} to show something else,
  \item
    \emph{reconfigure} to show a different arrangement,
  \item
    \emph{encode} to show a different representation,
  \item
    \emph{abstract/elaborate} show more or less detail,
  \item
    \emph{filter} show something conditionally,
  \item
    \emph{connect} show related items.
\end{enumerate*}

\todo[inline]{The classifications are all redundant! Explain why and choose one classification for later use}
\todo[inline]{Give one example for each category of the chosen classification}

\subsection{Interaction Theory}
\todo[inline]{no section without text}

\paragraph{Space-Time Cube Operations}
is a concept introduced in 2014 by \textcite{Bach2014} to map temporal data into two dimensional visualizations.
Space-time-cubes are used to model two attributes of continuous data with temporal data along a third axis, therefore the name \emph{cube}.
While the transformations are rather static it is also possible to introduce activity into the transformations.
The authors describe user-independent \emph{animations} and user-controlled \emph{interactions}.
E.g.\ a transformation may display a given slice of the cube.
An animation would display one slice at a time and display the next slice every second.
Whereas the interaction would show the slice determined by a user-controlled slider.
Various transformations and their best use in practice are evaluated in this work.
The work focuses on temporal data and otherwise continuous data.
Interactions are not seen as an abstract entity, that need to be agnostic of the underlying data structure and visualization.
The authors admit ``our framework does not provide much guidance for interaction design: the design space for interactive operations has only been partially explored.''\cite[Other limitations, p.~15]{Bach2014}

\paragraph{ITlib\cite{Figueroa2001}} is an architecture and a framework of interaction techniques for virtual reality applications, designed to be extensible and flexible.
New interaction techniques can easily be added and application specific code is seamlessly integrated.
On a low level an interaction technique ``is modeled as a set of filters connected in a small data flow''\cite[Basic concept, p.~2]{Figueroa2001}.
These filters are the smallest process unit in the data flow.
Composed of input and output ports, they communicate with other filters, to receive data input from predecessors and send data output to successors.
The framework specifies and stores the interaction techniques along with its filters, the execution model and the scene in XML documents.
The authors chose XML because it can be parsed easily and they generate code in order to target various virtual reality toolkits and environments.

Even though the system describes interactions in an abstract way, the domain of the framework is clearly the interaction of a human body within a 3D virtual reality.
Certain assumptions are made, including the data model, which is the 3D scene, and human computer interaction devices, like the user's hand or the user's head.
The goal is not to better understand the data, as the data model in this case is the 3D scene, and not statistical data.
Most important, the framework describes interaction techniques for a single viewpoint but not for coordinated multiple views.

\paragraph{Focus+Context Visualization} by \textcite{Bjork1999} is one of the few formalizations of information visualizations.
The authors describe this formalization based on first-level and second-level visualization:
\subparagraph{Visualizations} referred to as $IV$, are triples of a set $[D]$ of underlying data, a visual representation $V$ and $I$ which is the possible interaction or manipulation.
\begin{equation}
  IV([D], V, I)
\end{equation}
If $I$ affects $[D]$ we can manipulate the underlying data set.
Examples would be changes in a spreadsheet editor, or a change of the start and end date of an appointment in a calendar.
When $V$ is affected by $I$ the user can manipulate $IV$ in order to change the way $[D]$ is represented, e.g.\ choosing a different level of detail as shown in Figures~\ref{fig:theory:treemap-german-exports-1} and~\ref{fig:theory:treemap-german-exports-2}.

\subparagraph{Second-level Visualizations} are information visualizations consecutively applied.
The underlying data set $[D]$ of the previous formula is replaced with some information visualization $IV$, which is compatible with $IV'$.
\begin{equation}
  IV'(IV, V', I')
\end{equation}


Focus+context visualizations are second-level visualizations.
An example given by the authors is the  ``rubbersheet'' visualization, that visually distorts a first-level visualization similar to a magnifier.




\clearpage
\section{Use case}\label{sec:use-case}
\todo[inline]{No section without text}

\subsection{Data Sets}
For our uses cases, we have two different data sets:
One data set consists of a user ranking of public broadcasting in Germany, i.e.\ entities, mostly TV and radio broadcasts, are liked or disliked by people.
This data is public data and can be used by media researchers of broadcasting corporations but also targets media journalists and the general audience.
The other set, called \riso{}, consists of statistical data from various German administrations and is used by the authorities for urban planning and policy strategies.

Both data sets share some characteristics.
The administrative data connects certain features with certain regions of Germany.
As Germany is a federal state, larger regions consist of many other smaller regions.

The second one consists of user data that was collected through a web application called \rufu{}.

\subsubsection{RISO}

The \riso{} data base is used in by local authorities to get insights about governmental KPIs to assist local and regional decision making.
It is a relational database and a part of the data base schema is shown as an ER diagram in Figure~\ref{fig:data:riso}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/riso}
  \caption{Part of the \riso{} database schema. Primary keys are set in bold.}\label{fig:data:riso}
\end{figure}

The largest table is called \attr{data} with approximately 10,466,600 records, which holds all values along with the survey date.
\paragraph{Features}
This data is connected to a feature table through a foreign key called \attr{id_mm}.
In the feature table we can find the description for every referenced feature, e.g.\ population density, working population in agriculture, education spending.
The \riso{} system groups all features in a 4-level hierarchy:
\begin{enumerate}
  \item
    \attr{katalog_daten_1_kategorien}
  \item
    \attr{katalog_daten_2_themenfelder}
  \item
    \attr{katalog_daten_3_themen}
  \item
    \attr{katalog_daten_4_merkmale}
\end{enumerate}
The actual features table is the last one in the list.
At the lowest level within the hierarchy, this is the largest table with 1234 records.


\paragraph{Regions}
On the other side, the geographical data is stored in the \attr{regions} table.
The geometry data for each region is stored in the \attr{geojson} column and as the name suggests, the data type is a \attr{geojson}.
The foreign keys that connect the tables \attr{data} and \attr{regions} are called \attr{id_re} and \attr{regs}.
Unlike the feature table, the regions are grouped through the \attr{id_re} that indicates the hierarchy level.
So the values of the \attr{id_re} column denominate the level of the hierarchy.
E.g.\ a region with a \attr{id_re} of $1$ is a federal state of Germany, a region with id $13$ is a constituency.
A textual description for the hierarchy level can be found in the \attr{katalog_raumebenen} table in column \attr{raumebene}.
Both column \attr{id_re} and \attr{regs} belong to the primary key of the regions table, so there will never be two regions on the same hierarchy level with the same \attr{regs} id.

\paragraph{Characteristics}
As we can see, the schema of the \riso{} database follows a rather denormalized approach.
The schema does not make a lot of assumptions regarding the input data.
It allows to add data of arbitrary size, features and completeness as long as there is some kind of numerical data associated with some kind of geographical unit.
This approach is suitable for a data base that incorporates data from different sources, as it is the case with the \riso{} data base.


\subsubsection{\rufu{}}
Unlike the \riso{} database, the data base of \rufu{} is used as persistence layer.
For that reason the data base schema follows the requirements of a web application in production.

As outlined in Section~\ref{sec:outline} \rufu{} is an evaluation platform for public broadcasting in Germany.
First, users vote on broadcasts, i.e.\ they decide if they want to support broadcast or if they do not want to support.
As a next step, user can define a weighting by distributing a virtual, monthly budget among the chosen broadcasts.

Figure~\ref{fig:data:rundfunk} shows the data base schema of the application.
A \attr{user} is connected to \attr{broadcast} through a \attr{selection}.
If the \attr{user} supports some a broadcast, the \attr{response} on the given \attr{selection} will be `positive'.
If the \attr{user} does not wish to support a \attr{broadcast}, the \attr{response} will be `neutral'.
The \attr{user} can allocate virtual money to supported broadcasts.
The money will be stored in the column \attr{amount} of the \attr{selection}.
The sum of all amounts for one user will never exceed the virtual budget of 17.50€.

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/er}
  \caption{Database schema of the \rufu{} app}\label{fig:data:rundfunk}
\end{figure}

\paragraph{Features}
We have both numerical as well as nominal features.
A numerical feature could be the number of supporters from an area in Germany.
A nominal feature could be a list of the most supported broadcasts from an area in Germany.
Numerical and nominal features can be combined, so we could request for every region, a distribution of the desired expenditure for radio, TV, online and other broadcasts.

\paragraph{Regions}
\rufu{} stores the geometry for each region in \attr{geojson} files.
These files hold a \attr{FeatureCollection}.
Every \attr{Feature} is a region, the identifier is stored as a property.
We merge the geometry data with features for every request.
To be precise: We get all the user data, group it by the identifier \attr{state_code} and merge it with the geometry in the \attr{geojson}.

\paragraph{Characteristics}
The data base schema is a result of the specific requirements of the persistence layer.
Changes in the source code may require a migration of the data base schema.

However, we can ask a lot of questions already with common data base queries or standard data analysis tools:
\begin{enumerate}
  \item
    How does the actual support of a broadcast compare to the average support of a broadcast?
  \item
    What are the most popular broadcasts in Berlin?
  \item
    What is the desired ratio of genres of supported broadcasts? How important is education compared to sport?
  \item
    How does the support of a broadcast change over time?
  \item
    According to the user ranking, which broadcasts are similar to each other?
\end{enumerate}


\subsection{Existing Interactions}
We will now classify the implemented interactions of our two applications according to the classification by \textcite{Yi2007} in Section~\ref{sec:related-work:categories}.

\paragraph{In our \visan{}} possible interactions can be categorized into the classes \emph{select}, \emph{explore}, \emph{reconfigure}, \emph{encode} and \emph{filter}.
As seen in Figure~\ref{fig:analysis:interaction:existing} the user can \emph{select} one item in the view by clicking on it.
The user can reveal a tooltip showing the item properties by hovering with the mouse on the item, which is another \emph{selection}.
The user can \emph{explore} the map in the usual manner:
If the user drags with the mouse on the map, a panning operation is performed with the viewpoint focused on Germany, i.e.\ the camera moves around like a turntable.
The zoom factor can be changed by scrolling on the canvas of the map.
\emph{Encode} and \emph{reconfigure} techniques are performed through the menu on the left side:
Under the ``features'' tab, the user can \emph{reconfigure} different data sets and the displayed diagram, e.g.\ a tree map visualization based on the geometry shape, cubes or voronoi regions.
The tab ``Dimensions'' allows the user to \emph{encode} properties of a data set to visual attributes, e.g.\ the height, color and texture of an item.
The tab ``Filter'' can be used to reduce the displayed data set along a range of continuous values.
Figure~\ref{fig:analysis:interaction:existing:filter} shows the range of visible values in the left menu.
When the user drags the slider, the items in the map on the right side are updated interactively.

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/existing-interactions.png}
  \caption{%
    Items can be highlighted with a click, Bavaria is currently highlighted.
    A mouse over reveals a tooltip showing item properties.
    The menu on the left side allows to change the data set and the specific base visualization.
  }\label{fig:analysis:interaction:existing}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/existing-interactions-filter.png}
  \caption{%
    Only gas stations with a price for E10 within 1.349 Euro and 1.589 Euro are displayed in the map
  }\label{fig:analysis:interaction:existing:filter}
\end{figure}

\subsection{Planned Interactions}
We have a focus on coordinated multiple views consisting of a tree map and a geographical map.
Let's have some examples how an interaction between a \tmap{} and a \map{} might work:

    \begin{enumerate}
      \item
        User selects a feature set from the drop down in the menu. This will trigger a \emph{Reconfigure} interaction. A data set consisting of all features and their ids, geometries and metadata is transferred. The receiving components are both the \tmap{} and the \map{} which will rerender the entire visualization.
      \item
        User hovers with a mouse over a polygon in the \map{}. This will trigger a \emph{Select} interaction. The data is a single feature id that will be transferred to the \tmap{}, which will change the color of an box.
      \item
        Rotate or zoom the \tmap{}. This will also rotate or zoom the \map{}. The interaction would fall into \emph{Explore} and the shared information is the orientation of the camera and the zoom level.
      \item
        A click in the \tmap{} will trigger an \emph{Explore} interaction. The data is a single feature id sent to the \map{}. The map will center the viewport on the center of geometry of the respective feature.
      \item
        The user selects many features at once in the \map{} by dragging a rectangle. The ids of all features within the rectangle are sent to the \tmap{}. All features will be highlighted with a different color, which is therefore a \emph{Select} interaction.
      \item
        \emph{Reconfigure} the layouting of the \tmap{} by choosing a different hierarchy level. This increased granularity may lead to an increased granularity in the \map{}, e.g.\ show postal codes instead of federal states. The changed data are additional items, that are nested in the former items.
      \item
        \emph{Encode} the \tmap{} by a different attribute mapping like color, height or texture. If the \map{} has no geometry data that defines the shape of a feature, it can also display a larger point marker.
      \item
        Apply a \emph{Filter} and reduce the data set by choosing only items with metadata beyond a certain treshold. The reduced data leads to a full re-render of all data visualizations. The message contains the updated item list
  \item
    Show a \emph{Connect} by highlighting boxes of the same subtree in the \tmap{}. The respective connected items would be highlighted in the \map{} as well. Here the data is a relation between items.
    \end{enumerate}
\todo[inline]{What are the key interactions in our use case?}


\clearpage
\section{Analysis}\label{sec:analysis}
One purpose of this section is to abstract and deduce the essential characteristics of any interaction.
These characteristics are relevant for a formalized language of \cmvs{}.
To accomplish this goal, we take the approach of deducing the characteristics by example.
We analyze each data visualization example in terms of the expected data structure and dependent and independent visual variables~\cite{Bertin2010}.
We suggest interactions for each visualization as well as interactions that run on multiple views.
Those interactions will be classified according to \textcite{Yi2007} and the relevant subject of the interaction is specified.

The second outcome of this section is a set of requirements which can be used to evaluate a framework of \cmvs{}.


\subsection{Single Visualization Interactions}\label{sec:analysis:examples}

The data visualization catalogue by Severino Ribecca list many of the most used data visualizations\cite{VisualizationCatalogue2017}.
Let's pick some of those and derive a number of possible interactions.

%\begin{tabular}{l l l l}
    %Comparisons & Proportions & Relationships & Hierarchy \\
    %Concepts & Location & Part-to-a-whole & Distribution \\
    %How things work & Processes \& methods & Movement or flow & Patterns \\
    %Range & Data over time & Analysing text & Reference tool \\
%\end{tabular}


\paragraph{Line diagrams}
\begin{figure}
  \begin{center}
    \subfloat[Line diagram]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/line-diagram.png} }}%
    \qquad
  \end{center}
  \caption{Line charts are used to display trends}\label{fig:concept:chart-types:line-diagrams}
\end{figure}

Line diagrams are multiple sets of data, displayed along the x-axis.
They are used to display quantitative value over a continuous interval or time span.
It is possible to highlight an entire series of data or just a feature within that series.

\conceptTable{Tabular data, many data sets as series.}{Position, orientation, texture.}{Color, shape, size.}

\begin{figure}
    \begin{center}
        \caption{Interactions for line charts}%
        \label{fig:concept:chart-types:line-diagrams:interactions}
        {\small
            \begin{tabulary}{\textwidth}{ll}
                \bf Select & Highlight a data point (id of data point) \\
                \bf Select & Highlight a data series (id of data series) \\
                \bf Encode & Change colours of data series (data series \rightarrow\ colour) \\
                \bf Filter & Restrict interval on x-axis (filter function of data attribute) \\
                \bf Filter & Hide a data series (id of data series) \\
            \end{tabulary}
        }
    \end{center}
\end{figure}



\paragraph{Bar charts and multiset bar charts}

\begin{figure}
  \begin{center}
    \subfloat[Bar chart]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/bar-chart.png} }}%
    \qquad
    \subfloat[Multiset bar chart]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/multiset-bar-chart.png} }}%
  \end{center}
  \caption{A multiset bar charts is a variation of a bar chart}\label{fig:concept:chart-types:bar-charts}
\end{figure}

Bar charts and multiset bar charts show one or many attributes per feature along an axis.
They have in common that they encode the data attribute into the height of the eponymous bars.
Colors might be used to better distinuish between the different data attributes.
Features can be arbitrarily ordered along the axis, although multiset bar charts group features along a series of categories.

Therefore, bar charts need to be initialized with the set of features and their values as well as the groups of features for the multiset bar chart.
The supplied colours would colour each feature in a group in turn.
The set of possible ineractions include the highlighting of features, the reordering of features and a change in encoding of colour values.

\conceptTable{Tabular data, many data sets as series}{Size, orientation.}{Position, colour, shape, texture.}

\begin{figure}
    \begin{center}
        \caption{Interactions for bar charts}\label{fig:concept:chart-types:bar-charts:interactions}
        {\small
            \begin{tabulary}{\textwidth}{ll}
                \bf Select & Highlight a bar (id of data point) \\
                \bf Encode & Change colours of data series (colours \rightarrow{} data series) \\
                \bf Reconfigure & Sort by attribute (data attribute) \\
                \bf Reconfigure & Drag bars to reorder data series (ordered list of ids of data points) \\
                \bf Filter & Hide a data series (id of data series) \\
            \end{tabulary}
        }
    \end{center}
\end{figure}


\begin{figure}
  \centering
    \includegraphics[width=0.4\textwidth]{images/chartTypes/histogram.png}%
    \label{fig:concept:chart-types:histograms}
    \caption{A histogram is a bar chart over a continuous interval}%
\end{figure}

Histograms visualise the distribution of data over a continuous interval or certain time period.
A special type is the population pyramid, which is a pair of back-to-back histograms, one for each sex.
The difference of histograms to bar charts lies in the type of data itself, not the representation.
Therefore these charts need to be initialized with the same data and the same interactions can be applied.

\conceptTable{Tabular data, many data sets as series}{Size, orientation, position.}{Color, shape, texture.}

\paragraph{Bubble charts and scatter plots}

\begin{figure}
  \centering
    \subfloat[Bubble chart]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/bubble-chart.png} }}%
    \qquad
    \subfloat[Scatter plot]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/scatter-plot.png} }}%
    \caption{Bubble charts and scatter plots are similar regarding interactions}%
    \label{fig:concept:chart-types:bubble-chart}
\end{figure}

Bubble charts are popular choices to display a distribution of features.
The chart is initialized with coordinates for each feature, a colour and a size in case of a bubble charts.
Possible interactions include the highlighting of features, a different colour encoding, a reconfiguration to map another attribute to size.
Bubble charts may show only a window of the available data and allow to zoom in, zoom out or move the window along the axes.

\conceptTable{Tabular data, single data set with x- and y-coordinates}{Size, position.}{Color, shape, texture, orientation.}

\begin{figure}
    \begin{center}
        \caption{Interactions for bubble charts}%
        \label{fig:concept:chart-types:bubble-chart:interactions}
        {\small
            \begin{tabulary}{\textwidth}{ll}
                \bf Select & Highlight a bubble (id of data point) \\
                \bf Explore & Zoom in, zoom out (width and height of window) \\
                \bf Explore & Move viewport position (x- and y-coordinates of viewport) \\
                \bf Encode & Change mapping of colour to category (data series \rightarrow\ colour) \\
                \bf Encode & Change colour function (function value \rightarrow\ colour) \\
                \bf Encode & Change data attribute to colour (data attribute) \\
                \bf Encode & Change data attribute to size \\
                \bf Reconfigure & Sort by attribute (data attribute) \\
                \bf Reconfigure & Drag bars to reorder data series (ordered list of ids of data points) \\
                \bf Filter & Hide a data series (id of data series) \\
            \end{tabulary}
        }
    \end{center}
\end{figure}

\paragraph{Stacked bar charts}

\begin{figure}
  \centering
    \subfloat[Stacked bar chart]{{\includegraphics[width=0.3\textwidth]{images/chartTypes/stacked-bar-without-baseline.png} }}%
    \qquad
    \subfloat[Stacked bar chart with baseline]{{\includegraphics[width=0.3\textwidth]{images/chartTypes/stacked-bar-with-baseline.png} }}%
    \caption{Stacked bar charts can be ordered along a baseline or stretch to 100\% width to show the percentage-of-the-whole of each group}%
    \label{fig:concept:chart-types:stacked-bar-chart}
\end{figure}
\begin{figure}
  \centering
    \includegraphics[width=0.4\textwidth]{images/chartTypes/population-pyramid.png}%
    \label{fig:concept:chart-types:population-pyramid}
    \caption{A population pyramid can be modeled as a stacked bar chart}%
\end{figure}

Unlike a multi-set bar graph which displays their bars side-by-side, stacked bar graphs segment their bars of multiple datasets on top of each other.
A baseline, as shown in figure~\ref{fig:concept:chart-types:stacked-bar-chart} might be modeled as two back-to-back multi-set bar graphs. A reordering would e.g.\ move one data set from the left side to the right side.
Possible interactions include the highlighting of a feature, a change of color mapping, reordering of the baseline.

\begin{figure}
    \begin{center}
        \caption{Interactions for stacked bar charts}%
        \label{fig:concept:chart-types:stacked-bar-chart:interactions}
        {\small
            \begin{tabulary}{\textwidth}{ll}
                \bf Select & Highlight a bar (id of data point) \\
                \bf Encode & Change mapping of category to colour (data series \rightarrow\ colour) \\
                \bf Reconfigure & Sort by attribute (data attribute) \\
                \bf Reconfigure & Reorder Y axis (ordered list of ids of data points) \\
                \bf Reconfigure & Sort stacking order by attribute (data attribute) \\
                \bf Reconfigure & Specify the stacking order data series (ordered list of ids of data series) \\
                \bf Reconfigure & Specify a negative data series (list of ids of data series) \\
                \bf Filter & Hide a data series (id of data series) \\
            \end{tabulary}
        }
    \end{center}
\end{figure}

\conceptTable{Tabular data, multiple date sets as series}{Size, shape, orientation.}{Color, position, texture.}

\paragraph{Hierarchical visualizations}

\begin{figure}
  \centering
    \subfloat[Tree map]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/treemap.png} }}%
    \qquad
    \subfloat[Sunburst diagram]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/sunburst.png} }}%
    \caption{Tree maps and sunburst diagrams are ideal to show hierarchies}%
    \label{fig:concept:chart-types:hierarchies}
\end{figure}

Treemaps are great to show hierarchical data without ever exceeding the availabe screen.
Each feature is a assigned a rectangle according to a layouting algorithm.
Unlike a tree map a hiearchical ring diagram or sunburst diagram shows each level of the tree as a series of rings.

Therefore, both tree map and ring diagram need the feature set as a tree, with each node having a data attribute for layouting. Every node may be assigned a color.
As we are describing hierarchies, the maximal depth of tree may be increased or decreased.
Again, interactions could include a highlighting of features and a change of color encoding.
Both visualizations may show only a subtree.
E.g.\ a click on a box in the treemap opens another treemap focused on the subtree.
Similarly a click on a slice of the ring would surround the most external ring with the children of the feature.

\conceptTable{Tree, each feature has a value for layouting.}{Position, Size, shape, orientation.}{Color, texture.}

\begin{figure}
    \begin{center}
        \caption{Interactions for hierarchical visualizations}%
        \label{fig:concept:chart-types:hierarchies:interactions}
        {\small
            \begin{tabulary}{\textwidth}{ll}
                \bf Select & Highlight a feature (id of data point) \\
                \bf Explore & Use another node as root of the visible tree (id of data point) \\
                \bf Encode & Change mapping of category to colour (data series \rightarrow\ colour) \\
                \bf Reconfigure & Change data attribute used for layouting (data attribute) \\
                \bf Reconfigure & Sort by attribute (data attribute) \\
                \bf Reconfigure & Specify order (ordered list of ids of data points) \\
                \bf Abstract/Elaborate & Specify maximum depth of visible tree (number of levels) \\
            \end{tabulary}
        }
    \end{center}
\end{figure}

\paragraph{Geographical Data}

\begin{figure}
  \centering
    \subfloat[Choropleth map]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/choropleth-map.png} }}%
    \qquad
    \subfloat[Flow map]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/flow-map.png} }}%
    \caption{Choropleth maps focus on a density while flow maps show a migration of data}%
    \label{fig:analysis:chart-types:geographical}
\end{figure}

Choropleth maps and flow maps are specialized diagrams focused on geographical data.
Size, position and shape of a feature is defined by the geometry data of a feature.
In choropleth maps the color of each feature is based on a data attribute.
Flow maps may display connections between features, a data value defining the size of each arrow.

\conceptTable{Graph data with edges, each feature has geometry data.}{Position, Size, shape, orientation.}{Color, texture.}

\begin{figure}
    \begin{center}
        \caption{Interactions for geographical visualizations}%
        \label{fig:concept:chart-types:geographical:interactions}
        {\small
            \begin{tabulary}{\textwidth}{ll}
                \bf Select & Highlight a feature (id of data point) \\
                \bf Explore & Move viewport (latitude and longitude of viewport)\\
                \bf Explore & Zoom in, zoom out (zoom factor) \\
                \bf Encode & Change shape of marker (data id \rightarrow\ shape) \\
                \bf Encode & Change mapping of category to colour (data series \rightarrow\ colour) \\
                \bf Encode & Change colour function (value \rightarrow\ colour) \\
                \bf Encode & Change data attribute used for colour (data attribute) \\
                \bf Connect & Show relations of a feature (id of data point)  \\
                \bf Abstract/Elaborate & Change granularity of displayed regions (number of levels) \\
            \end{tabulary}
        }
    \end{center}
\end{figure}

\paragraph{Activity diagrams}
\begin{figure}
  \centering
    \subfloat[Calendar]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/calendar.png} }}%
    \qquad
    \subfloat[Gantt chart]{{\includegraphics[width=0.4\textwidth]{images/chartTypes/gantt-chart.png} }}%
    \caption{Similar to a calendar, a gantt chart shows activities and the progress along a time line}%
    \label{fig:concept:chart-types:temporal}
\end{figure}

In activity diagrams, each feature is represented as a rectangle, with the duration of the activity mapped to size and position.
Calendars and gantt charts could not only read the data from the data source, but also add new features to the data set or update metadata of a feature, e.g.\ the progress of the activity.

\conceptTable{Temporal data, each feature has a time interval.}{Position, Size, orientation.}{Color, shape, texture.}

\begin{figure}
    \begin{center}
        \caption{Interactions for temporal visualizations}%
        \label{fig:concept:chart-types:temporal:interactions}
        {\small
            \begin{tabulary}{\textwidth}{ll}
                \bf Select & Highlight a feature (id of data point) \\
                \bf Explore & Show a different period of dates (start and end datetime)\\
                \bf Explore & Show a different time interval (start and end hour)\\
                \bf Encode & Change color of categories or activities (data series \rightarrow\ colour) \\
                \bf Encode & Change data attribute used for colour (data attribute) \\
                \bf Filter & Remove a calendar or a category (id of data series) \\
            \end{tabulary}
        }
    \end{center}
\end{figure}

\subsection{Multiple View Interactions}\label{sec:analysis:examples}

\paragraph{Detail view}
\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{images/chartTypes/multi/detail-view}
  \caption{The screenshot-tool ``shutter'' shows a magnified detail view of the area around the mouse cursor in the lower right corner of the screen}\label{fig:concept:chart-types:detail}
\end{figure}

\subsection{Requirements}
In this subsection, we list a set or requirements imposed on a \cmv{} framework.
These requirements can be used for further evaluation.
\paragraph{Serialization} is the process of translating objects that can be stored or transmitted and reconstructed later.
In order to coordinate interactions among views, information needs to be passed from one view to another. 
A framework for \cmvs{} should therefore find a serialization format for interactions which has
\begin{enumerate*}[label=(\arabic*)]
  \item
    small payloads and
  \item 
    fast serialization and deserialization.
\end{enumerate*}

\paragraph{Reversibility} in the context of a \cmv{} framework means if it is possible to undo the effect of an interaction.
Ideally, every interaction function should have a well-defined inverse.
For every interaction that is not reversible, the computational cost to replay the interactions from the original state up to the point of the interaction should be minimal.

\paragraph{Data extensibility} indicates the ease of reloading and updating data on the fly.
This is especially important if an interaction requests additional data from an external service.
We consider good extensibility when
\begin{enumerate*}[label=(\arabic*)]
  \item
    additional data attributes can be added without lookup of corresponding items and
  \item
    no de-duplication steps are necessary when new items are added.
\end{enumerate*}

\paragraph{Development costs} qualify how much time and effort is needed in order to develop new components for the \cmv{} framework.
We track these costs in working days and the number of changed lines of code.


\paragraph{Maintainability} means in our case, how much other views are impacted by a change of an interaction in one view and how error-prone the framework is.
In general it is hard to measure maintainability.
For the \cmv{} framework we want to measure the
\begin{enumerate*}[label=(\arabic*)]
  \item
    lines of code and the
  \item
    cycliomatic complexity. We will try to find a means to measure
  \item
    cohesion and
  \item 
    coupling in the framework.
\end{enumerate*}
We assume that the amount of shared data between views is an indicator for high coupling.





\begin{bullshit}
\subsection{Free visual variables allow for interaction effects}

In order to communicate the interaction to the user, the effect of the visualization must be communicated back to the user by a visual change.
Data visualizations have \emph{dependent} and \emph{independent} visual variables, see~\ref{sec:theory:visual-variables}.
Dependent variables are those that are tied to a data attribute.
These constrained visual attributes are unavailable while independent visual variables are therefore available to be used for a visual feedback of an interaction.

\subsection{List events as candidates for interaction triggers}

Interaction can be triggered by any input of a human-computer-interaction device, like the keyboard or the mouse.
Because users are in the habit of expecting certain interactions to be triggered from certain events, we also have constraints here.
E.g.\ the viewpoint in geographical maps is moved by mouse drag events and the zoom level is controlled by the mouse wheel.
So we should not use those already occupied events as triggers for our coordinated interactions.
Nevertheless, consistency in user interfaces is crucial for great user experience, because users can reuse the learned knowledge.
Therefore, we need to list all availabe events as candidates and connect them to our interactions in a preferrably consistent manner.

On the other hand, we might have special controls in visualizations, in order to change the encoding.
E.g.\ a \tmap{} shows a menu where the user can define how attributes are mapped to visual variables.
\end{bullshit}


\clearpage
\section{Concept}\label{sec:concept}
Based on the findings in Section~\ref{sec:analysis} we specify a formal language and a conceptual framework for \cmvs{} in this section.
Our approach involves the definition of the terminology and the basic components of the conceptual framework.
The first component is the shared data model on which all visualizations must agree on.
We formalize each interaction from Section~\ref{sec:analysis} as a mathematical function and group these functions together if they have the same input and output.
As a last step, we specify the communication pattern of the formalized language.

\subsection{Terminology}
We introduce a couple of new terms in order to give a formal definition of the conceptual framework

\paragraph{Trigger} describes the event that starts an interaction.
As we have seen in Section~\ref{sec:analysis} every interaction is started by a user action.
The user e.g.\ clicks on a shape in the view, hovers over an area, selects an item from a dropdown menu, turns around a mobile device, speaks into the microphone or makes a particular gesture.
If the event of action is handled by a view and causes an interaction, we call this handling a \emph{trigger}.
Every view is responsible of its \emph{triggers}.
These are implementation details and are not shared by other views.

\paragraph{Effect} is the change of the visual representation subsequent to the interaction.
In order to be perceivable by the user, the interaction must have some visual effect, i.e.\ a change in the visual representation of the data.
Examples are:
A change of colour of a selected bubble, a movement of the viewpoint, a rearrangement of attributes in a parallel plot or a higher level of detail in a \tmap{}.
Every view is responsible of its visual \emph{effects}.
Those are implementation details as well and they are not shared by other views.
Obviously visual effects are not shared, as it depends on the visualization if visual variables are constrained or available to express a visual effect.

In singular visualizations, interactions consist of at least of a trigger and an effect:
\begin{equation}
  I(T, E)
\end{equation}
The meaning of the interaction in a singular view can be implicit.
E.g.\ hovering over a geographic area changes the background colour of the polygon and the user can identify the interaction as a \emph{highlighting}.
Note that this implicit meaning must be explicit in \cmvs{} so that other views are able to process it.


\paragraph{Subject} refers to the target of the interaction.
We must define what data or meta-data is affected by the interaction.
E.g.\ when a user moves the mouse cursor on a line in the line diagram, that could highlight the \emph{data point} under the cursor as well as the entire \emph{data series}.
Therefore we call the object affected of an interaction the interaction \emph{subject}.
A subject can be a data point, a list of data points, a position of the viewpoint, a certain order of attributes or a mapping of attributes to visual variables.

\paragraph{Verb} refers to the application specific context and purpose of the interaction.
A developer may want to have many \emph{select} interactions.
E.g.\ the user desires to select a detail view of an item under the mouse cursor from a previously selected set of already highlighted items.
Therefore we allow for a user-defined \emph{verb}.
The verb describes the interaction in the context of a task or an intention that is intrinsic to the application the interaction happens in.

\paragraph{Interaction function} is the declaration and definition how the subject of the interaction should be changed.
The aforementioned explicit meaning of the interaction is the smallest unit of information of the interaction.
This meaning is shared among multiple views, it is agnostic of how the interaction is implemented.
Therefore the meaning is shared between multiple views.
We call this meaning the \emph{interaction type}.
Some examples of interaction types include: Selection, Deletion, Point-of-Interest, Filtering, Reordering, Re-encoding.
Interaction types can be classified with the interaction categories of \textcite{Yi2007}.

Note that different information visualizations implement an interaction types in a different way or maybe not at all:

E.g.\ a bubble chart might encode a certain data attribute to the colour of a bubble.
Therefore the colour would not be changed for an interaction of type \emph{Selection} but the texture of the bubble.

A user may perform an interaction of type \emph{Reordering} on the series of a stacked bar chart.
This can have no effect on a coordinated scatter plot, as the position of each data point depends on its dimension.

\paragraph{Sentence} is the minimal set of information to coordinate an interaction across multiple views.
We define a sentence $S$ as:
\begin{equation}
    S(V, F(IS))
\end{equation}
With $V$ as a verb, an interaction function $F$ and the interaction subject $IS$.
See Section~\ref{sec:concept:types} for a list of interaction functions.
A sentence contains everything necessary to ensure the interaction can be reflected in another view.

\paragraph{Application context} is name for the state which is exclusive to the specific application.
Part of the application context is the access to data sources and the procedure to initialize data visualization with it.
Also, the binary files of textures, icons and vectors that describe the visual representation of a shape and colour themes are part of the application context.

\subsection{Formalization of an interaction}

We formalize an interaction $I$ as follows:
\begin{equation}
  I(T, S(V, F(IS)), E)
\end{equation}
For a trigger $T$, a sentence $S$ and the effect $E$.
The sentence $S$ is composed of a verb $V$, an interaction function definition $F$ and an interaction subject $IS$.
The part of the interaction which is shared among multiple views is the sentence $S$.
The function definition $F$ is defined by the triggering view at runtime.
E.g.\ when a parallel plot rearranges the list of attributes, the exact order will be determined by the view itself, during the handling of the drag-and-drop action.

\subsection{Conceptual Framework}
\todo[inline]{no section without text}

\subsubsection{Shared data model}\label{sec:concept:data-model}
To account for the various data structures, we use an abstract data model that is powerful enough to include tabular, hierarchical and relational data.
You can see a class diagram in figure~\ref{fig:concept:shared-data-model}.

The \emph{entity} class is used to model the smallest distinguishable unit.
All entities can be identified and retrieved via the \emph{id}.
An entity is defined to be any object that can have data attributes attached as \emph{dimensions}.

While entities describe what an object \emph{is}, a \emph{dimension} describes what it \emph{has}.

An entity can have arbitrary many attributes and each value can be accessed by the name of the attribute.
So if you want to get the \emph{latitude} value of an entity, you can retrieve the value with a call to the dimension \emph{latitude}.

Entities can also be \emph{series} of other entities.
A series contains an ordered list of contained entities.
As series can also contain other series, so we can model a hierarchy relation.

Every entity has a \emph{parent} which is the series it is contained in.
The root entity of the hierarchy has a parent which is \attr{nil}.
Every series has a special attribute \attr{height} that describes the number of nested series or the height of the subtree.

If we just want to display tabular data, we just have one or two levels of hierarchy.
E.g.\ one level of hierarchy for a histogram and two levels of hierarchy for a stacked bar chart.

Other relations than hierarchical relations can be modeled as a \emph{relation} entity.
It represents a directed edge in a graph and must have incoming and outgoing entity.
Since every \emph{relation} is an \emph{entity} as well, we can add \emph{attributes} to the relation.
These attributes may describe e.g.\ the weight of an edge in a flow map.


\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\textwidth]{images/concept/shared-data-model.png}
  \caption{%
    A data structure for tabular, hierarchical and relational data
  }\label{fig:concept:shared-data-model}
\end{figure}

\subsubsection{Predefined Interaction Functions}\label{sec:concept:types}

It turns out that we can describe the types of an interaction as a mathematical function.
These functions operates on the ids of \emph{entities}, \emph{series}, and \emph{relations} or their respective \emph{attributes}.
The name of the function is the \emph{type} of the interaction and the function domain being the \emph{subject} of the interaction.
Thus, we can describe interaction through a change of its semantic but we ignore implementation details of specific visualizations.


These function are derived from specific interactions of the examples in Section~\ref{sec:analysis:examples}.
Domain and range of these functions refer to the objects defined in the data model in Section~\ref{sec:concept:data-model}.
To declare the functions explicitly, we define a couple of sets:

\begin{equation} \mathbb{E} : \mathbb{E} \subseteq \mathbb{N}  \end{equation}
  The set of all entities in our subject space.
  Each entity can be represented by its \attr{id}, so for simplicity $\mathbb{E}$ is a subset all natural numbers in $\mathbb{N}$.

\begin{equation} \mathbb{D} : \mathbb{D} \subseteq \Sigma^* \end{equation}
  The set of all dimensions in our shared data model.
  Dimensions of a data set are the attributes of our data model and both terms are used synonymously in the following.

\begin{equation} Space(\mathbb{D}) \end{equation}
  Where $Space$ is the range of values of a dimension $d \in \mathbb{D}$.

  For convenience, we define this set with a function $Space$ which maps the name of a dimension $d$ to its set of possible data values.
  So for an attribute \attr{name} that would be the set of all strings.
  For continuous values, that would be the set of all real numbers $\mathbb{R}$.
  But $Space(D)$ also includes the set of all possible discrete values of dimension. 

\begin{equation} \mathbb{V} = \{x,y,y2,y3\ldots{}yn,z,height,colour,size,shape,orientation\ldots{}\} \end{equation}
  A discrete set to capture visual variables position, size, orientation, texture, colour and shape, as described in Section~\ref{sec:theory:visual-variables}.
  It is required to allow for \emph{encoding} interactions, that change the mapping of a dimension to a visual variable.

Note about notation:
The power set of all entities in $E$ is written as $ \mathcal{P}(\mathbb{E})$ and is the set of all subsets of $E$.
The list of all sequences of all entities in $E$ is written as $ \mathbb{E^*} $ and includes all enumerations of $\mathcal{P}(E)$.
The empty set is written as $\varnothing$.
If a function has the empty set as its domain, it expects no arguments.
Such a function is also called a constant.

The following is a list of functions describing the types based on the aforementioned sets:

\begin{equation} Select: \varnothing \rightarrow \mathcal{P}(\mathbb{E}) \end{equation}
  The constant $Select$ takes no arguments and returns a subset of selected entities.
  A $Select$ can be used to highlight entities or to show details of entities.
  It can be used to mark entities for deletion or to temporarily hide entities.
  In addition it possible to focus the visualization on these entities.

  An example of the latter:
  A geographical map could move the viewpoint position and the zoom level such that all focused entities in $Select()$ are visible.
  Hierarchical visualizations, e.g.\ tree maps or sunburst maps, may choose a single focused entity to be the root node of the currently displayed subtree.

\begin{equation} Filter: \mathbb{E} \rightarrow \{ \bot, \top \} \end{equation}
  The $Filter$ function describes which entities are part of the visualization.
  It can be implemented explicitly or implicitly.
  An explicit implementation would returns \attr{true} or \attr{false} based on the fact if an entity is part of an already known set.
  Implicit implementations would be based on the values of the dimensions of the entity.
  A threshold function is a good example of an implicit implementation.

\begin{equation} Window: \mathbb{D} \rightarrow \mathcal{P}(Space(\mathbb{D})) \end{equation}
  This function defines the currently visible section of the vector space of the dimensions in $\mathbb{D}$.
  For each of the dimensions in $\mathbb{D}$, the function returns the currently visible subset.

  The subset can be defined implicitly or explicitly:
  For charts with continuous values along the x- and y-axes, the function returns the representatives \attr{from} and \attr{to}.
  These representatives implicitly define the interval in $Space(\mathbb{D})$.
  If a dimension has discrete values, this function can also return an explicit set of values.

  Scatter plots, bar charts, line diagrams, bubble charts all have two coordinate axes.
  Therefore \attr{x} and \attr{y} will each be mapped to a pair of values $(from,to) \in \mathbb{R}$.
  Geographical visualizations have the camera pointing to the center of the earth.
  We have three degrees of freedom, so we would map \attr{latitude}, \attr{longitude} and \attr{zoom} to three values in $(lat,long,z) \in \mathbb{R}$.
  In a calendar we map \attr{fromDay}, \attr{toDay}, \attr{fromHour} and \attr{toHour} to define the currently visible time section.
  A special attribute of our shared data model is the height of the subtree of an entity, i.e.\ how many nested series we have below that entity.
  Therefore we can also map \attr{height} to a single value to define the maximum depth of the currently visible subtree in a tree map.

\begin{equation} Order: \mathbb{E} \times \mathbb{E} \rightarrow \mathbb{R} \end{equation}
  The $Order$ function is used to order two arbitrary entities $e1, e2 \in \mathbb{E}$.
  If $e1 < e2$ then the return value $r$ will be $ r < 0 $.
  For $e1 = e2$ the statement $r = 0$ holds and for $e1 > e2$ then $r > 0$.

  Similar to $Filter$, the $Order$ function can either be implemented explicity or implicitly.
  An explicit implementation returns a value $r$ based on the relative position of $e1$ to $e1$ in a given sequence.
  An implicit implementation would return a value $r$ based on some computation of dimensions of $e1$ and $e2$.
  E.g.\ ordering entities based on the alphabetical order of their name would be an example of the latter.

\begin{equation} Encode: \mathbb{D} \rightarrow \mathbb{V} \end{equation}
  The $Encode$ function can be used to change any mapping of dimension to any visual variable.
  E.g.\ bar charts, line diagrams, histograms and bubble charts can change the attribute mapped to the \attr{y} and \attr{x} axes.
  Bubble charts can encode a different data attribute in the \attr{size} of the bubbles.
  Choropleth maps, treemaps and bubble charts can map a different attribute to the \attr{colour}.
  A specialized version of this function may return the attribute that is used for the \attr{layout} of the tiling algorithm in tree maps.
  Note that parallel plots have arbitrary many \attr{y} axes.
  To define the order of dimensions displayed in a parallel plot, each dimension will be mapped to a named \attr{y} axis, e.g. $y1, y2 ... y3$ and so on.

Let's have some examples how these functions can be applied on coordinated interactions:

A user clicks on a bar in a bar chart and this feature then changes its background colour.
To coordinate the highlighting, the bar chart view will formulate a new sentence composed of a \emph{Select} function and the verb \emph{highlight}.
The function returns the set with the highlighted entity.

Let's say, a geographical map should move the position of the viewpoint on a entity.
The triggering view will use a function \emph{Select} this time with a verb \emph{focus}.
A treemap as a third view could pick up that interaction and show a subtree with the focused entity as root node. 

A view may show some controls to filter the data set, e.g.\ two sliders on an attribute called \attr{prize}.
When the user releases the mouse, an interaction with the function \emph{Filter} and the verb \emph{Hide} will be triggered.  
The function will then check the \attr{prize} of every entity and returns \attr{true} if the prize is within the given lower and upper limit, \attr{false} otherwise.

\subsubsection{Communication pattern}

In Section~\ref{sec:concept:types} we discussed how we can describe the types of the interaction.
The interaction type determines the signature of the function and describes the interaction itself.
However a type does not define how interactions are \emph{coordinated} among views.
E.g.\ what action in one view should lead to what kind of changes in what other views?
What is the communication pattern or what is the protocol how sentences are exchanged in the conceptual framework?

Figure~\ref{fig:concept:communication-pattern} gives an overview on the message flow in the communication pattern.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/concept/communication-pattern.png}
  \caption{%
    The message flow of the communication pattern:
    Every view can decide for itself whether to trigger an interaction or respond to an interaction with a visual effect.
    This is done by a user-defined verb.
  }\label{fig:concept:communication-pattern}
\end{figure}

Sometimes a visualization may not be able to interpret an interaction.
E.g.\ a bar chart can re-arrange the bars along the x-axis in case of a \emph{Reconfigure} interaction.
But a scatter plot constrains x- and y-coordinates of an entity on a certain data attribute.
Therefore, not only the \emph{trigger} and \emph{effect} is implementation specific, but also the handling of the interaction itself.

Every visualization decides on its own, how to react to a certain interaction.
That leads us to distinguishable, named interactions.
Every view can subscribe to certain interactions and receive messages in form of changed interaction types.
In order trigger an interaction, the visualization simply publishes to the named interaction.

This pattern is known as the \emph{Publish-subscribe pattern} and widely used in message queues.
The term \emph{interaction} in our case is equivalent to the term \emph{channel} or \emph{topic} commonly used in message queues.


\clearpage
\section{Implementation}\label{sec:implementation}

This section describes the implementation details for the described concepts.
We start with a list of to be implemented features.
Next, we describe the architecture of the software and why we chose this architecture.
What requirements and considerations lead to this particular architecture.


\subsection{Implemented interactions}

In the course of this thesis we want to implement the following interactions:
\begin{itemize}
  \item
    \emph{Select}: The user clicks on a building or region in a geographical map and all affected properties in the \tmap{} will be highlighted.
  \item
    \emph{Explore}: The user clicks on a block in the \tmap{} and the viewpoint in the geographical map will be centered on relevant area.
  \item
    \emph{Reconfigure}: The user selects a different feature set and the changes are reflected in both the geographical map (e.g. point instead of polygon geometries) and in the \tmap{}.
  \item
    \emph{Filter}: The user double-clicks on a region in a geographical map and the \tmap{} will be based on data of only that region.
\end{itemize}

\subsection{Standards}
\todo[inline]{no section without text}

\paragraph{GeoJSON} is the name of the data format used to exchange geometries.

An example of aggregated user data merged with geometry data can be seen in listing~\ref{lst:geojson:example}.
\lstinputlisting[language=JavaScript, label={lst:geojson:example}, caption={Geojson example}]{listings/example.geojson}

We can use this data as input for our common \visan{}, e.g.\ figure~\ref{fig:implementation:user_distribution} shows the user distribution of \rufu{}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/ua_example.png}
  \caption{%
    User distribution of \rufu{} across German federal states
  }\label{fig:implementation:user_distribution}
\end{figure}

\paragraph{Web components} is a recent standard of the W3C\cite{W3C2017} to bring component-based software engineering to the world wide web.
They look perfectly suited to be used in \cmvs{}.
However the attributes of web components are string based.
If arbitrary javascript objects need to be passed into the web component it is suggested to use one of the common javascript frameworks that allow for data binding.

\subsection{Software patterns}
Figure~\ref{fig:implementation:sequence-diagram} shows how \cmvs{} can be automatically updated even if the environment lacks a native update-mechanism.

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/sequence-diagram.png}
  \caption{%
    The sequence diagram shows the notification of different components.
  The user first chooses a feature set and hovers over a polygon in the geographical map.
  }\label{fig:implementation:sequence-diagram}
\end{figure}


\paragraph{The Observer pattern} allows multiple \emph{observers} to react to changes of an observed state.
In our case, the observed state is the \attr{MultiviewController}.
Any change to the \attr{MultiviewController} will subsequently be broadcasted to all connected views.


\paragraph{Publisher subscriber}
In our particular case we apply a special form of the observer pattern, the so called ``Publish-subscribe'' pattern\cite{Eugster2003}.
Publish-subsribe is a messaging pattern which is widely used in message queues.
In this scenario, senders of messages simply categorize their messages which will be consumed by subscribers of the category.
The scenario has very low coupling, publishers do not even need to know the existence of subscribers.

\paragraph{Component pattern}
State-of-the-art javascript frameworks like ReactJS and EmberJS follow the component pattern for the architecture of a single page web application.
The component pattern imposes a hierarchical structure on a website.
Each component is responsible for a task and may contain other components.
The components are joined at the root node of the page.

This pattern is very applicable to \cmvs{}.
The different views of \cmvs{} share state, i.e.\ the feature, that is currently highlighted or the applied filter on the data.
So the views are components and their closest common ancestor is the \cmv{} itself, controlling state and passing user interaction down to it's children.

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/data-down-actions-up.png}
  \caption{%
    Implementation of the component pattern in EmberJS\@.
    The example shows a page of a webshop.
    The customer is about to order the items in the shopping cart.
  }\label{fig:implementation:data-down-actions-up}
\end{figure}

\paragraph{Actions up --- Data down}

Version 2.0 of Ember introduced a common phrase how to use this pattern effectively: ``Data down, actions up''\cite{Emberigniter2017}
In the domain of \cmvs{} actions would mean user interactions, e.g.\ a click on a feature.
The action will notify the controlling \cmv{} component.
Actions may change data, and the changes will be passed to to all dependen views.
These views are then rerendered.

Examples for the kind of data that might trigger a rerendering of a view:
\begin{itemize}
  \item
    The selected feature or a list of selected features
  \item
    A list of thresholds for certain features as a filter
\end{itemize}
\subsection{Geographical Data Visualization}

\todo[inline]{Introduce the implementation of the geographical map}


\subsubsection{Client-side rendering frameworks}

We evaluated three javascript frontend frameworks for our application: \emph{GlimmerJS}, \emph{Google Polymer} and \emph{ReactJS}.
Figure~\ref{fig:implementation:frontend-frameworks} shows the pros and cons of each framework for our use case.

\paragraph{GlimmerJS} is the rendering enginge of EmberJS\cite{Ember2017}.
In 2017 it was released as a standalone framework.
Applications written in GlimmerJS can be exported as web components.
These web components can be included in any website, which makes GlimmerJS a reasonable choice to build high-quality widgets for user interfaces.
GlimmerJS also uses handlebars\cite{Handlebars2017}, a user-friendly templating language.
The downside of GlimmerJS is the current lack of documentation and immaturity due to the recent first release this year.

\paragraph{Google Polymer} is another popular library to build web components \cite{Polymer2017}.
With 18,469 stars on Github it is the most popular framework for web components at the time of writing.
Polymer has a large community and comprehensive documentation and therefore more suitable than GlimmerJS for our task.

Unfortunately, the web component standard does not specify how arbitrary Javascript objects can be passed to web components.
This raises some problems in legacy apps:
Usually, legacy apps are written in plain javascript without the use of a component-based frontend framework.
Any part of the code may call any other part of the code, leading to the dreaded ``spaghetti code''.
Refactoring the existing app requires the framework to have a reliable way of communication with the legacy parts.
E.g.\ parts of the legacy code call the backend in order to load data.
This data needs to be passed to the components of the user interface.
Web components do not have a designated interface
Because of that, libraries like Polymer come back on proprietary solutions.
But those proprietary solutions defeat the main advantage of developing against a standard, as it is unclear how components may interact with each other.

\paragraph{ReactJS} is a JavaScript library for building user interfaces\cite{React2017}.
After lifting the constraint to implement against web components, it is the frontend framework we finally decided to go for.
ReactJS does not have the ability to export web components.
It has, in return, an ascertained way of integrating the framework into a legacy app built with jQuery.
Along with its major advantage of easy integration, it has a striving community, heaps of documentation and tutorials and is well tested.

All of these reasons make us choose ReactJS for the task of coordinating multiple views in our existing \visan{}.


\todo[inline]{Pros/cons of GlimmerJS, Polymer, React}


\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/frontend-frameworks.png}
  \caption{Comparison of frontend frameworks}\label{fig:implementation:frontend-frameworks}
\end{figure}


\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{images/both-patterns-implemented.png}
  \caption{%
    Both observer pattern and component pattern applied in the field of \cmvs{}
  }\label{fig:implementation:both-patterns}
\end{figure}


\paragraph{Leaflet}
Leaflet is the leading open-source JavaScript library for mobile-friendly interactive maps~\cite{Leaflet2017}.
\todo[inline]{Show a code example how to use Leaflet}

\paragraph{PubSubJS}
PubSubJS is a topic-based publish/subscribe library written in JavaScript~\cite{PubSubJS2017}.
Topics are published asynchronuously.
\todo[inline]{Show a code listing here, how interaction verbs are mapped to topics}

\subsection{Coordination of Geographical Visualization and Treemap}

\todo[inline]{Introduce how we integrated the geographical map into the existing
treemap implementation}

\paragraph{Observer pattern and component pattern in \cmvs{}}
Figure~\ref{fig:implementation:both-patterns} shows the final result.
We try to put as much code as possible under the root node of ReactJS\@.
By that we eliminate the amount of custom updating implementation.
The root node of the DOM-tree of our react application is connected with the existing app through the common interface.
Both urban analytics controller and the multiview map component will observe changes to the common interface.
Also sub-components may communicate with the common interface.






\clearpage

\section{Evaluation}\label{sec:evaluation}
\todo[inline]{How and what can we evaluate?}
\todo[inline]{The performance?}
\todo[inline]{The flexibility?}

\section{Conclusion and Future Work}\label{sec:conclusion}
\todo[inline]{Did we achieve our goals?}
\todo[inline]{Is the concept sane in regarding the implementation?}

\todo[inline]{List stuff which was not accomplished in this master thesis}



\clearpage

\printbibliography{}
\end{document}



%\subsubsection{Use case specific problems}
%There is striking discrepancy of intentions between available metrics and the programme mandate of public broadcasting.
%TV ratings are produced by a group of 5000 representative homes equipped with a special TV box, while Radio ratings are carried out by phone surveys over the course of a year.
%Although created differently they share the same intention, i.e.\ to sell advertisements.
%
%We suspect that public broadcasting suffers from an overfitting problem:
%Since broadcasters have usage data only, they focus too much on people who still listen to the radio and watch TV.
%Young people especially show a decreasing interest in conventional mass media which has been shown in surveys.
%Public broadcasting fails in that respect that everybody has to pay and thus has a right to get access to information.

%In many cases, insights based on visualization techniques like \cmvs{} are used by experts for strategic decision-making.
%Thus, many advanced data visualizations techniques are made exclusively for professionals.
%
%On the other hand, data visualizations widely popular:
%Data journalism is one of the emerging fields in journalism.
%Facts and figures are the strongest evidence for opinionated journalistic reports.
%Not even a football match can do without a number based analysis.
%
%We believe that advanced data visualization techniques can be adopted and used in both an informative and strategic way by professionals as well as lay people.



% We use data visualizations in the context of the expenditure of public broadcasting fees in Germany.
% Since the year 2013 these fees are compulsory for every home in Germany and as a consequence, broadcasting receives €8,000,000,000 annually.
% Yet it is subject to little or no public feedback, ranking, or even debate on what constitutes value or quality.
% There is neither transparency on how the fees are spent nor a public feedback on how the fees should be spent.
%
% We see a great potential, a win-win situation to be precise, because both payers of the broadcasting fees and broadcasters themselves can benefit from each other.
% As of 2013 there is no legal opt-out anymore and people have a strong interest to say how their fees should be spent.
% Broadcasters on the other hand can evaluate their program based on the interests delivered by the users.
% This reciprocal relationship would create a public feedback for payers and a better program for broadcasters.
%
% This problem is perfectly suitable to be tackled with data visualizations.
% \todo[inline]{Explain why data visualization are good for communication}

%Our use case is creating a tool to publicly evaluate public broadcasting in Germany.

%Public broadcasting has a long history in all of Europe.
%Especially after the experiences of the Third Reich, freedom of the press and freedom of broadcasting in particular was defined in the German constitution, the basic law.
%Article 5 not only ensures the press to be free of censorship.
%It is interpreted in such a way that it guarantees broadcasting to exist and be politically and economically independent.
%It is remarkably in many ways:
%First, mass media are recognised to be a basic prerequisite for formation of opinion of the general public.
%Second, the state fosters free access to information, ie. Open Knowledge.

%Despite this highly positive ideal, reality looks somewhat different.
%Public broadcasting in Germany receives €8,000,000,000 (eight billion euros) annually, yet it is subject to little or no public feedback, ranking, or even debate on what constitutes value or quality.
%Since 2013, there is no legal opt-out for German citizen anymore.
%Every home in Germany has to pay for broadcasting whether or not the people actually use it.
%This has created numerous constitutional complaints and approximately 2 million homes in Germany refuse to pay, even it is virtually illegal to do so.

